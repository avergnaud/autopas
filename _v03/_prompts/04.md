# Prompt 04 — Auth OAuth2 Azure AD + Ansible Vault

## Contexte

`_v02` a livré : FastAPI opérationnel avec `/api/health`, config chargée au démarrage, Ansible complet (Nginx + HTTPS + service systemd). Le backend est en production sur `appsec.cc` mais sans aucune authentification ni interface web réelle.

Les secrets sont actuellement dans `ansible/files/.env` — ce fichier ne doit plus exister dans `_v03`.

## Objectif

Après ce step, ouvrir `https://appsec.cc/` → cliquer « Se connecter » → authentification SSO Azure AD → accès à une page privée affichant le nom et l'email de l'utilisateur connecté.

Les utilisateurs non listés dans `users.yaml` voient une page d'erreur (accès refusé), même s'ils ont un compte Azure AD valide.

---

## Secrets — Ansible Vault

### Stratégie

Les secrets ne doivent **jamais** être commités. Ils sont stockés dans un fichier Ansible Vault chiffré.

### Fichier `ansible/ansible.cfg` (nouveau)

```ini
[defaults]
vault_password_file = ~/.vault_pass
```

Ce fichier `~/.vault_pass` est créé manuellement par l'opérateur sur sa machine locale et n'est jamais commité.

### Fichier `ansible/vars/vault.yml` (nouveau, chiffré avec Ansible Vault)

Créé avec `ansible-vault create _v03/ansible/vars/vault.yml`, contient :

```yaml
vault_anthropic_api_key: "TODO_RENSEIGNER"
vault_azure_client_secret: "TODO_RENSEIGNER"
vault_session_secret_key: "TODO_RENSEIGNER"   # générer avec : openssl rand -hex 32
```

Ce fichier est commité chiffré. `ansible/files/.env` est supprimé.

### Template `ansible/templates/.env.j2` (nouveau)

```
ANTHROPIC_API_KEY={{ vault_anthropic_api_key }}
AZURE_CLIENT_SECRET={{ vault_azure_client_secret }}
SESSION_SECRET_KEY={{ vault_session_secret_key }}
```

### Mise à jour `ansible/playbook.yml`

- Ajouter `vars_files: [vars/vault.yml]` en tête du play.
- Remplacer la tâche `copy src: files/.env` par une tâche `template src: templates/.env.j2`.
- Ajouter une tâche de déploiement du répertoire `web/` vers `{{ web_root }}/`.

---

## Configuration — `data/config/app.yaml`

Modifier la section `oauth2` : `tenant_id` et `client_id` sont des valeurs non secrètes stockées directement dans `app.yaml` (l'opérateur les renseigne). Seul `client_secret` reste dans `.env`.

```yaml
oauth2:
  tenant_id: "TODO_RENSEIGNER"                  # ID du tenant Azure AD
  client_id: "TODO_RENSEIGNER"                  # ID de l'app registration
  redirect_uri: "https://appsec.cc/auth/callback"
  client_secret_env: "AZURE_CLIENT_SECRET"      # nom de la variable dans .env
  scopes:
    - "openid"
    - "profile"
    - "email"

session:
  secret_key_env: "SESSION_SECRET_KEY"          # nom de la variable dans .env
  max_age: 86400                                 # durée de vie cookie en secondes (24h)
```

---

## Configuration — `data/config/users.yaml`

Remplacer les emails réels par des placeholders :

```yaml
authorized_users:
  - email: "TODO_RENSEIGNER_1@domaine.com"
    role: "admin"
  - email: "TODO_RENSEIGNER_2@domaine.com"
    role: "user"
  - email: "TODO_RENSEIGNER_3@domaine.com"
    role: "admin"
```

---

## Code backend

### `app/auth/__init__.py`

Vide.

### `app/auth/azure_ad.py`

Client MSAL pour le flow Authorization Code. Expose :

- `build_auth_url(state: str) -> str` — construit l'URL de redirection vers Azure AD en utilisant `msal.ConfidentialClientApplication`. Le `state` est un nonce aléatoire anti-CSRF.
- `exchange_code(code: str, state: str) -> dict` — échange le code contre les tokens via `acquire_token_by_authorization_code`. Lève `AuthError` si l'échange échoue.
- Classe `AuthError(Exception)` locale au module.

La `ConfidentialClientApplication` est instanciée à la première utilisation (lazy init) depuis la config (`get_config()["oauth2"]`). `client_secret` est lu depuis `os.environ`.

### `app/auth/session.py`

Dépendance FastAPI pour les routes protégées.

- `get_current_user(request: Request) -> dict` — lit `request.session["user"]`. Si absent, lève `HTTPException(401)`.
- `get_optional_user(request: Request) -> dict | None` — même chose mais renvoie `None` au lieu de lever une exception. Utile pour les routes qui adaptent leur comportement selon l'état de connexion.

### `app/auth/router.py`

Router FastAPI (prefix vide, pas de prefix `/auth` dans le router lui-même — les routes sont définies en chemin complet pour clarté).

**`GET /auth/login`**
1. Génère un `state` aléatoire (`secrets.token_urlsafe(16)`).
2. Stocke `state` dans `request.session["oauth_state"]`.
3. Redirige vers l'URL Azure AD retournée par `build_auth_url(state)`.

**`GET /auth/callback`**
1. Vérifie que `request.query_params["state"] == request.session.get("oauth_state")`. Si non → `HTTPException(400, "Invalid state")`.
2. Appelle `exchange_code(code, state)`.
3. Extrait `email` et `name` depuis `id_token_claims` (champs `preferred_username` et `name`).
4. Vérifie que l'email est dans `get_config()["authorized_users"]`. Si non → redirige vers `/auth/denied`.
5. Stocke dans `request.session["user"]` : `{"email": email, "name": name, "role": role}`.
6. Supprime `request.session["oauth_state"]`.
7. Redirige vers `/private`.

**`GET /auth/logout`**
1. Vide `request.session`.
2. Redirise vers `/`.

**`GET /auth/denied`**
Retourne une page HTML simple : « Accès refusé. Votre compte n'est pas autorisé à utiliser cette application. » avec un lien retour vers `/`.

### Mise à jour `app/main.py`

1. Ajouter `SessionMiddleware` depuis `starlette.middleware.sessions` :
   ```python
   app.add_middleware(
       SessionMiddleware,
       secret_key=os.environ.get("SESSION_SECRET_KEY", "changeme"),
       max_age=get_config()["session"]["max_age"],
       https_only=True,
       same_site="lax",
   )
   ```
   Note : `SessionMiddleware` doit être ajouté **après** la création de l'app et **avant** le premier appel à `get_config()`. Gérer via le lifespan : charger la config d'abord, puis configurer le middleware. En pratique, utiliser une fonction de setup appelée dans `lifespan`.

   Alternative plus simple : lire `SESSION_SECRET_KEY` directement depuis `os.environ` au moment du `add_middleware` (la variable est chargée par `load_dotenv` dans `load_config()` — donc appeler `load_config()` en premier dans lifespan).

2. Inclure `auth_router` depuis `app.auth.router`.

3. Ajouter l'endpoint `GET /api/auth/me` :
   ```python
   @app.get("/api/auth/me")
   async def auth_me(user: dict = Depends(get_current_user)) -> dict:
       return user
   ```

4. Monter les fichiers statiques en **dernier** (après toutes les routes FastAPI) :
   ```python
   app.mount("/", StaticFiles(directory=web_dir, html=True), name="static")
   ```
   `web_dir = BASE_DIR / "web"`. Si le répertoire n'existe pas (dev local sans déploiement), logguer un warning et ne pas monter.

### Mise à jour `app/config.py`

Adapter la lecture de la section `oauth2` : `tenant_id` et `client_id` sont maintenant des valeurs directes dans `app.yaml` (plus des noms de variables d'environnement).

---

## Interface web

### `web/index.html`

Page publique minimaliste :
- Titre : « PAS Assistant »
- Bouton « Se connecter avec Microsoft » → lien vers `/auth/login`
- Si l'utilisateur est déjà connecté (détectable via un appel JS à `/api/auth/me` au chargement) : afficher « Vous êtes connecté — [Accéder à l'application](/private) »

### `web/private.html`

Page privée :
- Au chargement, appel `fetch('/api/auth/me')` :
  - Si 200 : afficher « Bonjour {name} ({email}) — Rôle : {role} » + bouton « Se déconnecter » → `/auth/logout`
  - Si 401 : rediriger vers `/`
- Message placeholder : « Application en cours de développement. »

### `web/style.css`

CSS minimaliste : centrage, police système, bouton sobre. Pas de framework externe.

---

## `requirements.txt`

Ajouter `itsdangerous>=2.1` (requis par `SessionMiddleware` de Starlette).

---

## Arborescence finale de `_v03/`

```
_v03/
├── app/
│   ├── __init__.py
│   ├── config.py               # modifié : lecture oauth2 direct depuis app.yaml
│   ├── main.py                 # modifié : SessionMiddleware, auth router, /api/auth/me, StaticFiles
│   └── auth/
│       ├── __init__.py
│       ├── azure_ad.py         # MSAL client
│       ├── session.py          # dépendances FastAPI (get_current_user, get_optional_user)
│       └── router.py           # /auth/login, /auth/callback, /auth/logout, /auth/denied
├── data/
│   └── config/
│       ├── app.yaml            # modifié : oauth2 avec tenant_id/client_id directs + section session
│       ├── questions.txt
│       ├── users.yaml          # modifié : emails TODO_RENSEIGNER
│       └── prompts/
│           ├── system_response.txt
│           ├── system_attention.txt
│           └── system_structure.txt
├── web/
│   ├── index.html
│   ├── private.html
│   └── style.css
├── ansible/
│   ├── ansible.cfg             # nouveau : vault_password_file = ~/.vault_pass
│   ├── inventory
│   ├── playbook.yml            # modifié : vars_files vault, template .env, deploy web/
│   ├── vars/
│   │   └── vault.yml           # nouveau : chiffré avec ansible-vault
│   ├── files/
│   │   └── index.html          # inchangé (peut être supprimé, remplacé par web/)
│   └── templates/
│       ├── .env.j2             # nouveau : génère .env depuis vault vars
│       ├── nginx-http.conf.j2
│       ├── nginx-https.conf.j2
│       └── pas-assistant.service.j2
├── requirements.txt            # modifié : + itsdangerous>=2.1
└── .env.example                # mis à jour : ANTHROPIC_API_KEY, AZURE_CLIENT_SECRET, SESSION_SECRET_KEY
```

---

## Hors scope (ce step)

- Bot Teams (auth via Bot Framework — différent mécanisme)
- Refresh token automatique
- Pages d'erreur soignées
- Tout endpoint métier (parsing, génération…)

---

## Instructions pour l'opérateur après déploiement

```bash
# 1. Créer le fichier mot de passe vault (une seule fois, sur la machine locale)
echo "mon_mot_de_passe_vault" > ~/.vault_pass
chmod 600 ~/.vault_pass

# 2. Créer et chiffrer le fichier vault
ansible-vault create _v03/ansible/vars/vault.yml
# → saisir les 3 secrets : vault_anthropic_api_key, vault_azure_client_secret, vault_session_secret_key

# 3. Renseigner les valeurs non secrètes
# Éditer _v03/data/config/app.yaml : tenant_id, client_id
# Éditer _v03/data/config/users.yaml : emails autorisés

# 4. Déployer
cd _v03/ansible
ansible-playbook -i inventory playbook.yml
```
